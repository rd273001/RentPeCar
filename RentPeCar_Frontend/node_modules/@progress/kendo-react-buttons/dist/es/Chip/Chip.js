var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { ChipListSelectionContext, ChipListFocusContext, ChipListDataContext } from './ChipList';
import { classNames, useDir, getTabIndex, Keys } from '@progress/kendo-react-common';
import { FOCUS_ACTION } from './focus-reducer';
import { DATA_ACTION } from './data-reducer';
import { SELECTION_ACTION } from './selection-reducer';
import { validatePackage } from '@progress/kendo-react-common';
import { packageMetadata } from '../package-metadata';
import { useMouse } from '@progress/kendo-react-common';
/**
 * Represents the Chip component.
 */
export var Chip = React.forwardRef(function (props, ref) {
    validatePackage(packageMetadata);
    var target = React.useRef(null);
    var chipRef = React.useRef(null);
    var dir = useDir(chipRef, props.dir);
    React.useImperativeHandle(target, function () { return ({
        element: chipRef.current,
        props: props
    }); });
    React.useImperativeHandle(ref, function () { return target.current; });
    var _a = React.useContext(ChipListSelectionContext), selection = _a[0], dispatchSelection = _a[1];
    var _b = React.useContext(ChipListFocusContext), focus = _b[0], dispatchFocus = _b[1];
    var _c = React.useContext(ChipListDataContext), dispatchData = _c[1];
    var selected = React.useMemo(function () {
        return (props.selected || (Array.isArray(selection)
            ? selection.some(function (i) { return i === props.value; })
            : selection === props.value));
    }, [props.selected, props.value, selection]);
    var focused = React.useMemo(function () { return focus === props.value; }, [props.value, focus]);
    var look = React.useMemo(function () { return props.look || defaultProps.look; }, [props.look]);
    React.useEffect(function () {
        if (focused && chipRef.current) {
            chipRef.current.focus();
        }
    }, [focused]);
    // React.useEffect(() => dispatchItemsContext({type: FOCUS_ACTION.register, payload: target }), []);
    var handleClick = React.useCallback(function (event) {
        dispatchSelection({ type: SELECTION_ACTION.toggle, payload: props.value, event: event });
    }, [props.onClick, dispatchSelection, props.value]);
    var handleRemove = React.useCallback(function (event) {
        if (!props.removable) {
            return;
        }
        dispatchData({ type: DATA_ACTION.remove, payload: props.value, event: event });
        dispatchFocus({ type: FOCUS_ACTION.reset, payload: props.value, event: event });
        dispatchSelection({ type: SELECTION_ACTION.remove, payload: props.value, event: event });
        if (props.onRemove) {
            props.onRemove.call(undefined, {
                target: target.current,
                syntheticEvent: event
            });
        }
    }, [props.onRemove, props.removable, dispatchData, dispatchFocus, dispatchSelection]);
    var handleKeyDown = React.useCallback(function (event) {
        switch (event.keyCode) {
            case Keys.left:
                dispatchFocus({ type: FOCUS_ACTION.prev, payload: props.value, event: event });
                break;
            case Keys.right:
                dispatchFocus({ type: FOCUS_ACTION.next, payload: props.value, event: event });
                break;
            case Keys.enter:
                dispatchSelection({ type: SELECTION_ACTION.toggle, payload: props.value, event: event });
                break;
            case Keys.delete:
                handleRemove(event);
                break;
            default:
                break;
        }
        if (props.onKeyDown) {
            props.onKeyDown.call(undefined, {
                target: target.current,
                syntheticEvent: event
            });
        }
    }, [props.onKeyDown, dispatchFocus, dispatchSelection, handleRemove]);
    var handleFocus = React.useCallback(function (event) {
        dispatchFocus({ payload: props.value, type: FOCUS_ACTION.current, event: event });
        if (props.onFocus) {
            props.onFocus.call(undefined, {
                target: target.current,
                syntheticEvent: event
            });
        }
    }, [props.onFocus, dispatchFocus]);
    var handleBlur = React.useCallback(function (event) {
        if (props.onBlur) {
            props.onBlur.call(undefined, {
                target: target.current,
                syntheticEvent: event
            });
        }
    }, [props.onBlur]);
    var mouseProps = useMouse(props, target, { onClick: handleClick });
    return (React.createElement("div", __assign({}, mouseProps, { role: props.role, id: props.value, style: props.style, ref: chipRef, dir: dir, tabIndex: getTabIndex(props.tabIndex, props.disabled, undefined), className: classNames('k-chip', {
            'k-rtl': dir === 'rtl',
            'k-state-disabled': props.disabled,
            'k-state-selected': selected,
            'k-state-focus': focused,
            'k-chip-success': props.type === 'success',
            'k-chip-warning': props.type === 'warning',
            'k-chip-error': props.type === 'error',
            'k-chip-info': props.type === 'info',
            'k-chip-has-icon': props.icon,
            // TODO: remove outlined and filled check once we deprecate them!
            'k-chip-outline': look === 'outline' || look === 'outlined',
            'k-chip-solid': look === 'solid' || look === 'filled'
        }, props.className), "aria-checked": selected, "aria-disabled": props.disabled, "aria-describedby": props.ariaDescribedBy, onFocus: handleFocus, onBlur: handleBlur, onKeyDown: handleKeyDown }),
        selected && React.createElement("span", { className: 'k-selected-icon-wrapper' },
            React.createElement("span", { className: "k-selected-icon k-icon " + (props.selectedIcon || defaultProps.selectedIcon) })),
        props.icon && React.createElement("span", { className: "k-icon k-chip-icon " + props.icon }),
        React.createElement("span", { className: 'k-chip-content' }, props.children !== undefined
            ? props.children
            : props.text &&
                React.createElement("span", { "aria-label": props.text, className: 'k-chip-label' }, props.text)),
        props.removable &&
            React.createElement("span", { className: 'k-remove-icon', onClick: handleRemove },
                React.createElement("span", { className: "k-icon " + props.removeIcon }))));
});
var propTypes = {
    id: PropTypes.string,
    text: PropTypes.string,
    value: PropTypes.any,
    type: PropTypes.oneOf([
        'none',
        'success',
        'warning',
        'error',
        'info'
    ]),
    dir: PropTypes.oneOf(['ltr', 'rtl']),
    removable: PropTypes.bool,
    removeIcon: PropTypes.string,
    disabled: PropTypes.bool,
    icon: PropTypes.string,
    selectedIcon: PropTypes.string,
    look: PropTypes.string,
    onRemove: PropTypes.func,
    dataItem: PropTypes.any,
    selected: PropTypes.bool,
    ariaDescribedBy: PropTypes.string
};
var defaultProps = {
    disabled: false,
    removable: false,
    selectedIcon: 'k-i-check',
    look: 'solid',
    removeIcon: 'k-i-close-circle',
    dir: 'ltr'
};
Chip.displayName = 'KendoReactChip';
// TODO: delete casting when @types/react is updated!
Chip.propTypes = propTypes;
Chip.defaultProps = defaultProps;
